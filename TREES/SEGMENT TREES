template<typename T> struct seg {
	ll n; //크기 (1-based로 쓰려면 1크게 넣어야 함)
	T id; //항등원
	vector<T> t;
	T(*merge)(T, T);
	seg(ll N, T ID, T(*_merge)(T, T)): n(N), id(ID), merge(_merge) { t.resize(N<<1, id); }					
	void update(ll p, T val) {
		for (t[p+=n] = val; p > 1; p >>= 1) {//기존 거랑 비교해서 바꿔야 하면 t[p+=n] = '그 값'으로 수정 필요.
			if(p&1) t[p>>1] = merge(t[p^1], t[p]);
			else t[p>>1] = merge(t[p], t[p^1]);
		}
	}
	T query(ll l, ll r) {//query on interval [l, r)
		T lret=id, rret=id;
		for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
			if(l&1) lret = merge(lret, t[l++]);
			if(r&1) rret = merge(t[--r], rret);
		}
		return merge(lret, rret);
	}
};

/*
ex1) 1~n을 관리하는 합 seg
seg<ll> s(n+1,0,[](ll a,ll b){return a+b;});

ex2) 0~n-1을 관리하는 min seg
seg<ll> s(n, inf, [](ll a,ll b){return min(a,b);});
*/

/*------------------------------------*/
// 구간에 min update를 하는 세그
// 약간 화성지도 같은 느낌..
ll arr[7] = {0, 1, 4, 2, 8, 5, 7};


struct segtree {
    vector<ll> tree;
    void make_tree(ll sz) {
        tree.resize(4 * sz + 4, 1e9);  // 값은 알아서 잘..
    }
    ll init(ll N, ll s, ll e) {
        if (s == e) return tree[N] = arr[s];
        ll mid = (s + e) / 2;
        return tree[N] = max(init(N * 2, s, mid), init(N * 2 + 1, mid + 1, e));
    }
    void update(ll N, ll s, ll e, ll l, ll r, ll val) {
        if (l > e || r < s) return;
        if (s == e) {
            tree[N] = min(tree[N], val);
            return;
        }
        else {
            if (tree[N] <= val) return;
            tree[N] = val;
            ll mid = (s + e) / 2;
            update(N * 2, s, mid, l, r, val);
            update(N * 2 + 1, mid + 1, e, l, r, val);
            tree[N] = max(tree[N * 2], tree[N * 2 + 1]);
        }
    }
    ll query(ll N, ll s, ll e, ll l, ll r) {
        if (l > e || r < s) return 0;
        if (l <= s && e <= r) return tree[N];
        ll mid = (s + e) / 2;
        return max(query(2 * N, s, mid, l, r), query(2 * N + 1, mid + 1, e, l, r));
    }
} seg;
