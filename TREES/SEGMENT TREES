template<typename T> struct seg {
	ll n; //크기 (1-based로 쓰려면 1크게 넣어야 함)
	T it; //항등원
	vector<T> t;
	T(*merge)(T, T);
	seg(ll N, T IT, T(*_merge)(T, T)): n(N), it(IT), merge(_merge) { t.resize(N<<1, it); }					
	void update(ll p, T val) {
		p += n;		
		for (t[p] = val; p > 1; p >>= 1) {//기존 거랑 비교해서 바꿔야 하면 t[p] = merge(val, t[p])
			if(p&1) t[p>>1] = merge(t[p^1], t[p]);
			else t[p>>1] = merge(t[p], t[p^1]);
		}
	}
	T query(T l, T r) {//query on interval [l, r)
		T lret=it, rret=it;
		for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
			if(l&1) lret = merge(lret, t[l++]);
			if(r&1) rret = merge(t[--r], rret);
		}
		return merge(lret, rret);
	}
};

/*
ex1) 1~n을 관리하는 합 seg
seg<ll> s(n+1,0,[](ll a,ll b){return a+b;});

ex2) 0~n-1을 관리하는 min seg
seg<ll> s(n, inf, [](ll a,ll b){return min(a,b);});
*/
